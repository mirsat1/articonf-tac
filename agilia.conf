input {
  file {
    type => ["car"]
    path => "C:/Users/sefid/Desktop/Od Stariot PC/Experimental Datasets/AGI Dataset/Car.csv"
    start_position => ["beginning"]
    sincedb_path => "NULL"
  }
  file {
    type => ["offer"]
    path => "C:/Users/sefid/Desktop/Od Stariot PC/Experimental Datasets/AGI Dataset/Offer.csv"
    start_position => ["beginning"]
    sincedb_path => "NULL"
  }
  file {
    type => ["travel"]
    path => "C:/Users/sefid/Desktop/Od Stariot PC/Experimental Datasets/AGI Dataset/Travel.csv"
    start_position => ["beginning"]
    sincedb_path => "NULL"
  }
  file {
    type => ["user"]
    path => "C:/Users/sefid/Desktop/Od Stariot PC/Experimental Datasets/AGI Dataset/Users.csv"
    start_position => ["beginning"]
    sincedb_path => "NULL"
  }
}
filter {
  if [type] == "car" {
    csv {
      separator => ","
      columns => ["carLicensePlate","brand","model","colour","seats","year","ownerId","deleted","state","observations"]
      convert => {
        "seats" => "integer"
        "year" => "integer"
        "deleted" => "boolean"
        "state" => "integer"
      }
    }
  }
  if [type] == "offer" {
    csv {
      separator => ","
      columns => ["id","car","priceForKm","priceForTime","startDate","endDate","startPlace.latitude","startPlace.longitude","startPlace.adress","endPlaces","available"]
      convert => {
        "priceForKm" => "float"
        "priceForTime" => "float"
        "startDate" => "date"
        "endDate" => "date"
        "startPlace.latitude" => "float"
        "startPlace.longitude" => "float"
        "available" => "boolean"
      }
    }
    date {
      match => [ "startDate", "UNIX" ]
      timezone => "CET"
    }
    mutate {
        rename => { "startPlace.latitude" => "[start_place][lat]" }
        rename => { "startPlace.longitude" => "[start_place][lon]" }
      }
    mutate {
        gsub => [
          "endPlaces", "longitude", "lon",
          "endPlaces", "latitude", "lat"
        ]
      }
    json {
      source => "endPlaces"
      target => "end_places"
    }
    mutate {
      remove_field => [ "message" ]
      remove_field => ["endPlaces"]
      }
  }
  if [type] == "travel" {
    csv {
      separator => ","
      columns => ["id","carLicensePlate","users","offerId","startPlace.latitude","startPlace.longitude","endPlace.latitude","endPlace.longitude","startDate","endDate","suggestedEndPlaces","kmTraveled","status","priceBalance","depositBalance","rewardBalance","startedBy","score","finishedBy","checkedBy","seats","rentForTime","totalPrice","observations"]
      convert => {
        "startPlace.latitude" => "float"
        "startPlace.longitude" => "float"
        "endPlace.latitude" => "float"
        "endPlace.longitude" => "float"
        "startDate" => "date"
        "endDate" => "date"
        "kmTraveled" => "float"
        "priceBalance" => "float"
        "depositBalance" => "float"
        "rewardBalance" => "float"
        "seats" => "integer"
        "rentForTime" => "boolean"
        "totalPrice" => "float"
      }
    }
    date {
      match => [ "startDate", "UNIX" ]
      timezone => "CET"
    }
    mutate {
        rename => { "startPlace.latitude" => "[start_place][lat]" }
        rename => { "startPlace.longitude" => "[start_place][lon]" }
        rename => { "endPlace.latitude" => "[end_place][lat]" }
        rename => { "endPlace.longitude" => "[end_place][lon]" }
      }
    mutate {
        gsub => [
          "suggestedEndPlaces", "longitude", "lon",
          "suggestedEndPlaces", "latitude", "lat",
          "startedBy", "longitude", "lon",
          "startedBy", "latitude", "lat",
          "finishedBy", "longitude", "lon",
          "finishedBy", "latitude", "lat",
          "checkedBy", "longitude", "lon",
          "checkedBy", "latitude", "lat"
          ]
        }
    json {
      source => "score"
      target => "pscore"
    }
    json {
      source => "users"
      target => "pusers"
    }
    json {
      source => "suggestedEndPlaces"
      target => "suggEndPlaces"
    }
    json {
      source => "startedBy"
      target => "started_by"
    }
    json {
      source => "finishedBy"
      target => "finished_by"
    }
    json {
      source => "checkedBy"
      target => "checked_by"
    }
    mutate {
      remove_field => ["message"]
      remove_field => ["score"]
      remove_field => ["users"]
      remove_field => ["suggestedEndPlaces"]
      remove_field => ["startedBy"]
      remove_field => ["finishedBy"]
      remove_field => ["checkedBy"]
    }
  }
  if [type] == "user" {
    csv {
      separator => ","
      columns => ["id","balance","reputation","payerId"]
      convert => {
        "balance" => "float"
        "reputation" => "float"
      }
    }
  }
}
output {
  if [type] == "car" {
    elasticsearch {
      hosts => ["http://192.168.15.220:9200"]
      index => ["car-agilia"]
    }
  }
  if [type] == "offer" {
    elasticsearch {
      hosts => ["http://192.168.15.220:9200"]
      index => ["offer-agilia"]
    }
  }
  if [type] == "travel" {
    elasticsearch {
      hosts => ["http://192.168.15.220:9200"]
      index => ["travel-agilia"]
    }
  }
  if [type] == "user" {
    elasticsearch {
      hosts => ["http://192.168.15.220:9200"]
      index => ["user-agilia"]
    }
  }
  stdout {codec => "dots"}
  if "_dateparsefailure" in [tags] {
    stdout {codec => "rubydebug"}
  }
  if "_grokparsefailure" in [tags] {
    stdout {codec => "rubydebug"}
  }
}
