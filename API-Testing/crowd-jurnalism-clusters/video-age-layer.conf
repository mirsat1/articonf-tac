input {
  http_poller {
    urls => {
      tag => {
        method => get
        url => "https://articonf1.itec.aau.at:30103/api/use-cases/crowd-journalism-enum/tables/video/layers/Video_Age_Layer/clusters"
        headers => {
          Accept => "application/json"
          Authorization => "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InJlZ3VsYXJAaXRlYy5hYXUuYXQiLCJjcmVhdGVkX2F0IjoiMjAyMS0wNC0xOSAxNjo1Nzo0OS4wNjQwNDIiLCJ2YWxpZF91bnRpbCI6IjIwMjEtMDQtMjAgMTY6NTc6NDkuMDY0MDQyIn0.buFPRVuRq1-FWW5ClqVU4U4UjIj962gLLCSm3ZBWLXU"
        }
      }
    }
    truststore => "C:/Users/Mirsat/Desktop/WORK/testing_logstash/API-Testing/smartapi.jks"
    truststore_password => "changeit"
    request_timeout => 4000
    connect_timeout => 100
    socket_timeout => 100
    schedule => { every => "30s" }
    codec => json
  }
}
filter {
  grok {
    match => {
      "label" => "%{NUMBER:lowNum} -- %{NUMBER:highNum}"
    }
  }
  mutate {
    add_field => {
      "customLabel" => "0"
    }
    add_field => {
      "earliestNode" => "0"
    }
    add_field => {
      "oldestNode" => "0"
    }
    add_field => {
      "avgNodesTimestamp" => "0"
    }
    add_field => {
      "meanNodesTimestamp" => "0"
    }
    add_field => {
      "nodes-count" => "0"
    }
    convert => {
      "customLabel" => "integer"
      "earliestNode" => "integer"
      "oldestNode" => "integer"
      "avgNodesTimestamp" => "integer"
      "meanNodesTimestamp" => "integer"
      "nodes-count" => "integer"
    }
  }
  ruby {
    code => "
    if event.get('[lowNum]').to_f.nonzero? and event.get('[highNum]').to_f.nonzero? then event.set('[customLabel]', ((event.get('[lowNum]').to_f + event.get('[highNum]').to_f) / 2).to_f) else event.set('[customLabel]', 0) end 
    "
  }
  if([nodes]){
    ruby {
    code => "
      count = 0
      nodesarr = []
      datesarr = []
      event.get('[nodes]').each{|k|
      count=count+1}
      event.get('[nodes]').each{|k, v|
      datesarr << k['creationTimestamp'].to_i}
      event.get('[nodes]').each{|k|
      k['geolocation_latitude']=k['geolocation_latitude'].to_f
      k['geolocation_longitude']=k['geolocation_longitude'].to_f
      k['geolocation']={'lat'=>k['geolocation_latitude'].to_f, 'lon'=>k['geolocation_longitude'].to_f}
      k['creationTimestamp']=k['creationTimestamp'].to_i
      k['totalPrice']=k['price'].to_f * rand(1..5).to_i
      if k['price'].to_f.nonzero? and k['totalPrice'].to_f.nonzero? then k['ROI']=((k['totalPrice'].to_f - k['price'].to_f) / k['totalPrice'].to_f) * 100 end
      if k['impactRating'].to_f.nonzero? or k['informativeRating'].to_f.nonzero? or k['trustinessRating'].to_f.nonzero? then k['avgRatings']=(k['impactRating'].to_f + k['informativeRating'].to_f + k['trustinessRating'].to_f) / 3 else k['avgRatings']=0 end
      k['dayOfWeek'] = Time.at(k['creationTimestamp'].to_i).strftime('%A')
      nodesarr << k
      }
      event.set('[earliestNode]', datesarr.max)
      event.set('[oldestNode]', datesarr.min)
      event.set('[avgNodesTimestamp]', (datesarr.sum / datesarr.length).to_i)
      event.set('[nodes-count]', count)
      event.set('[nodes]', nodesarr)
      if event.get('[earliestNode]').to_i.nonzero? and event.get('[oldestNode]').to_i.nonzero? then event.set('[meanNodesTimestamp]', ((event.get('[earliestNode]').to_i + event.get('[oldestNode]').to_i) / 2)) else event.set('[meanNodesTimestamp]', 0) end
    "
    }
  }
}
output {
  elasticsearch {
    hosts => ["http://15.237.93.29:8082/"]
    index => ["smart_crowd_jurnalism_video_age_layer_video_clusters"]
    document_id => "%{customLabel}"
    }
  stdout { codec => dots }
}